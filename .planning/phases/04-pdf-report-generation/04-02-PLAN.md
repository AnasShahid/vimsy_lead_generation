---
phase: 4
plan: 2
name: AI Report Content Generator
wave: 1
depends_on: none
autonomous: true
---

# Phase 4 Plan 2: AI Report Content Generator

## Objective

Build the AI service that generates three personalized report sections — Executive Summary, Recommendations, and Vimsy Pitch — using OpenRouter. The service takes a site's business context and analysis data as input and returns structured AI-generated content ready to be stored in the `site_reports` table and injected into the Handlebars template.

## Context

**Requirements addressed:** REQ-025 (partial — AI-generated personalized content)
**Phase goal contribution:** Provides the personalized intelligence layer that transforms raw analysis data into client-facing narrative sections, making each report unique and persuasive.

## Tasks

### Task 1: Create the report AI prompt

**Files:** `server/src/services/report/ai-report-generator.ts`

**Action:**
Create a new service file. Define a `DEFAULT_REPORT_AI_PROMPT` constant — a system prompt instructing the AI to generate three sections for a branded site health report.

The prompt should:
- Explain the role: "You are a professional technical writer for Vimsy, a WordPress maintenance service"
- Describe the three sections to generate:
  1. **Executive Summary** (3-5 paragraphs): High-level overview of the site's health, key findings, and urgency. Written to a non-technical business owner. Reference the company name, industry, and specific scores.
  2. **Recommendations** (5-10 bullet points): Actionable fixes prioritized by impact. Each recommendation should reference the specific finding (e.g., "Your SSL certificate expires in 12 days — renew immediately"). Group by category (Security, Performance, SEO, WordPress).
  3. **Vimsy Pitch** (2-3 paragraphs): Personalized CTA explaining how Vimsy can solve the specific issues found. Reference the industry and business type. End with a clear call to action.
- Specify JSON output format:
  ```json
  {
    "executive_summary": "...",
    "recommendations": "...",
    "pitch": "..."
  }
  ```
- Instruct: Use markdown formatting within each section (headers, bold, bullet points). Content should be professional but approachable. Avoid jargon. Reference specific numbers and findings from the data provided.

Store this as `DEFAULT_REPORT_PROMPT` and add a `getReportPrompt()` helper that reads from settings DB with fallback to default (same pattern as `getAIPrompt()`).

Add the default to `server/src/db/queries/settings.ts`:
- `export const DEFAULT_REPORT_PROMPT = ...`
- `export function getReportPrompt(): string`

**Verify:**
```bash
cd server && npx tsc --noEmit
```

**Done when:**
- Report prompt constant defined with clear instructions for all 3 sections
- `getReportPrompt()` reads from DB with default fallback
- Prompt instructs JSON output with `executive_summary`, `recommendations`, `pitch` keys

---

### Task 2: Build the report context assembler

**Files:** `server/src/services/report/ai-report-generator.ts`

**Action:**
Create a function `buildReportContext(site, analysis, contacts)` that assembles all available data into a structured text block for the AI.

Input types:
- `site: Site` — from `getSiteById()`
- `analysis: SiteAnalysis` — from `getAnalysisBySiteId()`
- `contacts: Contact[]` — from contacts query (count only, no PII in prompt)

The context string should include:

```
=== SITE INFORMATION ===
Domain: {domain}
Company: {company_name || 'Unknown'}
Industry: {industry_segment || industry_guess || 'Unknown'}
Country: {country || 'Unknown'}
Page Title: {page_title}
Description: {meta_description}
WordPress: {is_wordpress ? 'Yes' : 'No'}
AI Fit Assessment: {ai_fit_reasoning}

=== HEALTH SCORE ===
Overall: {health_score}/100 — {priority_classification}
Performance: {performance_score}/30
Security: {security_score}/30
SEO: {seo_score}/20
Availability: {availability_score}/20

=== PERFORMANCE (PageSpeed Insights) ===
Performance Score: {psi_performance_score}/100
Accessibility: {psi_accessibility_score}/100
SEO Score: {psi_seo_score}/100
Best Practices: {psi_best_practices_score}/100

=== SECURITY ===
SSL Valid: {ssl_valid}
SSL Issuer: {ssl_issuer}
SSL Expires: {ssl_expiry_date} ({ssl_days_until_expiry} days)
Protocol: {ssl_protocol_version}
Vulnerabilities Found: {vulnerabilities_found}
[If vulns > 0, list critical/high/medium/low counts]

=== WORDPRESS HEALTH ===
WP Version: {wpscan_wp_version} ({wpscan_wp_version_status})
Theme: {wpscan_theme} v{wpscan_theme_version}
Plugins: {count} detected [list names with outdated flags]
Users Enumerated: {count}
Config Backups Exposed: {count}
DB Exports Exposed: {count}

=== CONTACTS ===
Email contacts found: {contacts.length}

=== SCORING DEDUCTIONS ===
[Parse vulnerability_details JSON and list deduction reasons if available]
```

Handle null/missing values gracefully — show "N/A" or omit the line.

Parse JSON fields (`wpscan_plugins`, `vulnerability_details`) to extract readable summaries.

**Verify:**
```bash
cd server && npx tsc --noEmit
```

**Done when:**
- `buildReportContext()` produces a comprehensive text block from site + analysis data
- All analysis dimensions represented (security, performance, SEO, WP, availability)
- Null values handled gracefully
- JSON fields parsed into readable format

---

### Task 3: Create the AI generation function

**Files:** `server/src/services/report/ai-report-generator.ts`

**Action:**
Create the main export function:

```typescript
export interface ReportAIContent {
  executive_summary: string;
  recommendations: string;
  pitch: string;
}

export async function generateReportContent(
  siteId: number
): Promise<ReportAIContent>
```

Implementation:
1. Fetch site via `getSiteById(siteId)` — throw if not found
2. Fetch latest analysis via `getAnalysisBySiteId(siteId)` — throw if no analysis
3. Fetch contacts count (query contacts table for site_id count)
4. Build context string via `buildReportContext()`
5. Get report prompt via `getReportPrompt()`
6. Get AI model via `getAIModel()` (reuse existing setting)
7. Call OpenRouter via the same pattern as `ai-analyzer.ts`:
   ```typescript
   const client = new OpenRouter({ apiKey: process.env.OPENROUTER_API_KEY });
   const response = await client.chat.send({
     httpReferer: 'https://vimsy.com',
     xTitle: 'Vimsy Lead Gen - Report',
     chatGenerationParams: {
       model,
       messages: [
         { role: 'system', content: prompt },
         { role: 'user', content: contextString },
       ],
       temperature: 0.4,
       responseFormat: { type: 'json_object' },
       stream: false,
     },
   });
   ```
8. Parse JSON response, validate it has all 3 keys
9. Return `ReportAIContent` object

Error handling:
- If OpenRouter API key missing, throw descriptive error
- If AI returns invalid JSON, retry once with lower temperature (0.2)
- If retry fails, throw with partial content info
- Log AI generation time for monitoring

**Verify:**
```bash
cd server && npx tsc --noEmit
```

**Done when:**
- `generateReportContent(siteId)` returns `{ executive_summary, recommendations, pitch }`
- Uses OpenRouter with same client pattern as existing AI analyzer
- Handles missing data, API errors, and invalid JSON gracefully
- Logs generation time

---

## Verification

After all tasks complete:

```bash
# TypeScript compiles
cd server && npx tsc --noEmit

# Module exports are correct
node -e "const m = require('./server/dist/services/report/ai-report-generator'); console.log(Object.keys(m))"
```

## Success Criteria

- [ ] Report AI prompt covers all 3 sections with clear instructions
- [ ] `buildReportContext()` assembles comprehensive site + analysis data
- [ ] `generateReportContent()` calls OpenRouter and returns structured content
- [ ] JSON parsing with retry on failure
- [ ] Reuses existing OpenRouter client pattern and AI model setting
- [ ] TypeScript compiles cleanly

## Output

**Files created:**
- `server/src/services/report/ai-report-generator.ts` — AI content generation service

**Files modified:**
- `server/src/db/queries/settings.ts` — Add `DEFAULT_REPORT_PROMPT`, `getReportPrompt()`

---
phase: 4
plan: 4
name: Report Worker & Auto-Queue
wave: 2
depends_on: [04-01, 04-02]
autonomous: true
---

# Phase 4 Plan 4: Report Worker & Auto-Queue

## Objective

Create the report background worker that processes report generation jobs, the report API routes for triggering/listing/downloading reports, and the auto-queue mechanism that automatically creates a report job when analysis completes. This connects the data model (Plan 1), AI generator (Plan 2), and PDF renderer (Plan 3) into a working pipeline.

## Context

**Requirements addressed:** REQ-025 (partial — background generation, auto-queue, API)
**Phase goal contribution:** Makes report generation operational — reports can be triggered manually or auto-queued after analysis, processed in the background, and served via API.

## Tasks

### Task 1: Create the report orchestrator service

**Files:** `server/src/services/report/index.ts`

**Action:**
Create the main report orchestration function that ties together AI generation and PDF rendering for a single site:

```typescript
export interface ReportResult {
  success: boolean;
  reportId: number;
  pdfPath?: string;
  error?: string;
}

export async function generateSiteReport(
  siteId: number,
  reportId: number
): Promise<ReportResult>
```

Implementation:
1. Fetch site via `getSiteById(siteId)` — fail if not found
2. Fetch latest analysis via `getAnalysisBySiteId(siteId)` — fail if no completed analysis
3. Update report status to `'generating'`
4. Update site `report_status` to `'generating'`
5. Fetch report branding settings via `getReportSettings()`
6. Call `generateReportContent(siteId)` from `ai-report-generator.ts` to get AI content
7. Update report with AI content (`ai_executive_summary`, `ai_recommendations`, `ai_pitch`)
8. Call `renderReportPdf({ site, analysis, aiContent, branding })` from `pdf-renderer.ts`
9. Update report with `pdf_path`, `pdf_filename`, `status: 'completed'`, `generated_at`, snapshot `health_score` and `priority_classification`
10. Update site `report_status` to `'completed'`
11. Add tag `'reported'` to site

Error handling:
- If AI generation fails, update report status to `'error'` with error message, update site `report_status` to `'error'`
- If PDF rendering fails (after AI succeeds), still save AI content but mark status as `'error'`
- Log each step with `[Report]` prefix

**Verify:**
```bash
cd server && npx tsc --noEmit
```

**Done when:**
- `generateSiteReport()` orchestrates AI → PDF → DB update flow
- Report and site statuses updated at each stage
- AI content saved even if PDF rendering fails
- Errors handled and logged

---

### Task 2: Create the report worker

**Files:** `server/src/workers/report-worker.ts`

**Action:**
Create a poll-based background worker following the exact pattern of `analysis-worker.ts`:

```typescript
export function startReportWorker(): void
export function stopReportWorker(): void
export function cancelReportJob(jobId: string): boolean
```

Implementation:
- Poll interval: `2000ms` (same as other workers)
- Job type filter: `getNextPendingJob('report')`
- Max concurrent: `1` (report generation is heavy — AI call + Puppeteer)
- On job start: extract `siteIds` from `job.config` (type `ReportJobConfig`)
- Process sites sequentially (not in parallel — Puppeteer is memory-heavy):
  1. For each siteId, create a report record via `createReport(siteId, jobId)`
  2. Update site `report_status` to `'pending'`
  3. Call `generateSiteReport(siteId, reportId)`
  4. Update job progress after each site
- On job complete: update job status to `'completed'`
- On all sites error: update job status to `'failed'`
- Support cancellation via AbortController (check `signal.aborted` between sites)

**Verify:**
```bash
cd server && npx tsc --noEmit
```

**Done when:**
- Report worker polls for `'report'` type jobs
- Processes sites sequentially with progress updates
- Supports cancellation
- Follows same lifecycle pattern as analysis worker

---

### Task 3: Register report worker in server startup

**Files:** `server/src/index.ts`

**Action:**
Import and start the report worker alongside existing workers:

```typescript
import { startReportWorker, stopReportWorker } from './workers/report-worker';

// After startAnalysisWorker()
startReportWorker();
console.log('[Worker] Report worker started');

// In shutdown()
stopReportWorker();
```

Also initialize the Puppeteer browser on startup and close on shutdown:
```typescript
import { initBrowser, closeBrowser } from './services/report/pdf-renderer';

// After workers start
await initBrowser();
console.log('[Report] PDF renderer initialized');

// In shutdown()
await closeBrowser();
```

Note: The server entry point may need to become async if `initBrowser()` is async. Wrap the startup in an async IIFE if needed, or make `initBrowser()` lazy (initialize on first render call).

**Verify:**
```bash
cd server && npx tsx src/index.ts
# Should see: [Worker] Report worker started
# Should see: [Report] PDF renderer initialized
```

**Done when:**
- Report worker starts and stops with server lifecycle
- Puppeteer browser initialized at startup
- Graceful shutdown closes browser and stops worker

---

### Task 4: Create report API routes

**Files:** `server/src/routes/reports.ts`, `server/src/app.ts`

**Action:**
Create a new routes file and mount it in `app.ts`:

```typescript
app.use('/api/reports', reportRoutes);
```

Endpoints:

**POST /api/reports/generate**
- Body: `{ siteIds: number[] }`
- Validates all sites exist and have completed analysis
- Creates a job record (type: `'report'`, config: `{ siteIds }`)
- Returns `{ success: true, data: { jobId, sitesCount } }`

**GET /api/reports**
- Query params: `status?`, `page?`, `pageSize?`, `sortBy?`, `sortOrder?`
- Calls `listReports(filters)` — returns paginated list with site info joined
- Returns `{ success: true, data: { reports, total, page, pageSize } }`

**GET /api/reports/:siteId**
- Gets the latest report for a site via `getReportBySiteId(siteId)`
- Returns `{ success: true, data: report }` or 404

**GET /api/reports/:siteId/pdf**
- Gets the latest completed report for a site
- If report exists and has `pdf_path`, serve the file:
  ```typescript
  const fullPath = path.resolve('data', report.pdf_path);
  res.setHeader('Content-Type', 'application/pdf');
  res.setHeader('Content-Disposition', `inline; filename="${report.pdf_filename}"`);
  res.sendFile(fullPath);
  ```
- If no report or not completed, return 404

**GET /api/reports/:siteId/download**
- Same as `/pdf` but with `Content-Disposition: attachment` instead of `inline`

**POST /api/reports/:siteId/regenerate**
- Creates a new report job for a single site (same as generate but for one site)
- Returns `{ success: true, data: { jobId } }`

**GET /api/reports/jobs**
- Lists report jobs (reuse existing job listing with type filter)
- Returns `{ success: true, data: jobs }`

**Verify:**
```bash
# Start server
cd server && npx tsx src/index.ts &
sleep 2

# List reports (empty initially)
curl -s http://localhost:3001/api/reports | jq .

# Trigger generation for a site that has analysis
curl -s -X POST http://localhost:3001/api/reports/generate \
  -H "Content-Type: application/json" \
  -d '{"siteIds": [1]}' | jq .

kill %1
```

**Done when:**
- All 7 endpoints working
- Generate creates job and returns jobId
- PDF served inline for viewing, as attachment for download
- Regenerate creates new job for single site
- Proper error handling (404 for missing reports, 400 for invalid input)

---

### Task 5: Auto-queue reports after analysis completes

**Files:** `server/src/workers/analysis-worker.ts`

**Action:**
After the analysis worker marks a site as `'analyzed'` (in the `runAnalysisJob` function, after `batchUpdateSites([siteId], { analysis_status: 'analyzed' })`), auto-queue a report generation job for that site.

Implementation:
- Import `createJob` from `../db/queries/jobs`
- After a successful analysis for a site, create a report job:
  ```typescript
  // Auto-queue report generation
  const reportJobId = uuidv4();
  createJob({
    id: reportJobId,
    type: 'report',
    status: 'pending',
    provider: null,
    config: { siteIds: [siteId] },
    progress: 0,
    total_items: 1,
    processed_items: 0,
    error: null,
  });
  batchUpdateSites([siteId], { report_status: 'pending' });
  console.log(`[Analysis Worker] Auto-queued report generation for site ${siteId} (job ${reportJobId})`);
  ```

This means each analyzed site gets its own report job. The report worker will pick these up one at a time.

**Verify:**
```bash
# Trigger analysis for a site, then check that a report job was created
curl -s http://localhost:3001/api/reports/jobs | jq .
# Should show a pending report job after analysis completes
```

**Done when:**
- Analysis completion automatically creates a pending report job
- Site `report_status` set to `'pending'` when auto-queued
- Report worker picks up and processes the auto-queued job
- Log message confirms auto-queue

---

## Verification

After all tasks complete:

```bash
# 1. Server starts with report worker
cd server && npx tsx src/index.ts &
sleep 3

# 2. Report endpoints respond
curl -s http://localhost:3001/api/reports | jq .success
# → true

# 3. Generate a report (requires a site with completed analysis)
curl -s -X POST http://localhost:3001/api/reports/generate \
  -H "Content-Type: application/json" \
  -d '{"siteIds": [1]}' | jq .

# 4. Wait for worker to process, then check
sleep 30
curl -s http://localhost:3001/api/reports/1 | jq .data.status
# → "completed"

# 5. Download PDF
curl -s -o test-report.pdf http://localhost:3001/api/reports/1/pdf
file test-report.pdf
# → test-report.pdf: PDF document

kill %1
rm -f test-report.pdf
```

## Success Criteria

- [ ] Report orchestrator ties AI generation + PDF rendering into single flow
- [ ] Report worker polls for and processes report jobs sequentially
- [ ] Worker registered in server startup/shutdown lifecycle
- [ ] All 7 API endpoints functional (generate, list, get, pdf, download, regenerate, jobs)
- [ ] PDF served inline for viewing and as attachment for download
- [ ] Analysis completion auto-queues report generation
- [ ] Site `report_status` updated through lifecycle (pending → generating → completed/error)
- [ ] Cancellation supported

## Output

**Files created:**
- `server/src/services/report/index.ts` — Report orchestration service
- `server/src/workers/report-worker.ts` — Background report worker
- `server/src/routes/reports.ts` — Report API routes

**Files modified:**
- `server/src/index.ts` — Register report worker + Puppeteer lifecycle
- `server/src/app.ts` — Mount report routes
- `server/src/workers/analysis-worker.ts` — Auto-queue report after analysis

import { findVulnerabilitiesBySlugs } from '../../db/queries/vulnerabilities';
import { fetchUrl } from '../../utils/http';
import type { WPScanResult } from './wpscan';

interface VulnRecord {
  title: string | null;
  cve_id: string | null;
  cvss_score: number | null;
  cvss_rating: string | null;
  software_slug: string | null;
  affected_versions: string | null;
  patched_status: string | null;
  remediation: string | null;
}

export interface VulnerabilityMatch {
  software_slug: string;
  software_type: 'plugin' | 'theme' | 'core';
  detected_version: string | null;
  vulnerabilities: Array<{
    title: string;
    cve_id: string | null;
    cvss_score: number | null;
    cvss_rating: string | null;
    patched_status: string | null;
    remediation: string | null;
  }>;
}

export interface VulnerabilityMatchResult {
  matches: VulnerabilityMatch[];
  totalVulnerabilities: number;
  criticalCount: number;
  highCount: number;
  mediumCount: number;
  lowCount: number;
}

export async function matchVulnerabilities(wpscanResult: WPScanResult): Promise<VulnerabilityMatchResult> {
  const result: VulnerabilityMatchResult = {
    matches: [],
    totalVulnerabilities: 0,
    criticalCount: 0,
    highCount: 0,
    mediumCount: 0,
    lowCount: 0,
  };

  const slugsToCheck: Array<{ slug: string; type: 'plugin' | 'theme' | 'core'; version: string | null }> = [];

  if (wpscanResult.wpVersion) {
    slugsToCheck.push({ slug: 'wordpress', type: 'core', version: wpscanResult.wpVersion });
  }

  for (const plugin of wpscanResult.plugins) {
    slugsToCheck.push({ slug: plugin.slug, type: 'plugin', version: plugin.version });
  }

  if (wpscanResult.mainTheme) {
    slugsToCheck.push({ slug: wpscanResult.mainTheme.name, type: 'theme', version: wpscanResult.mainTheme.version });
  }

  if (slugsToCheck.length === 0) return result;

  // Step 1: Local DB lookup
  const allSlugs = slugsToCheck.map(s => s.slug);
  const dbVulns = findVulnerabilitiesBySlugs(allSlugs);

  // Merge into a loosely-typed record for combined local + API results
  const vulnMap: Record<string, VulnRecord[]> = {};
  for (const [slug, vulns] of Object.entries(dbVulns)) {
    vulnMap[slug] = vulns;
  }

  // Step 2: Fallback API for missing slugs
  const missingSlugItems = slugsToCheck.filter(s => !vulnMap[s.slug] || vulnMap[s.slug].length === 0);

  for (const item of missingSlugItems) {
    try {
      const apiVulns = await fetchFallbackVulnerabilities(item.slug, item.type);
      if (apiVulns.length > 0) {
        vulnMap[item.slug] = apiVulns;
      }
    } catch {
      // Fallback API failed, continue without
    }
  }

  // Step 3: Match versions and aggregate
  for (const item of slugsToCheck) {
    const vulns = vulnMap[item.slug] || [];
    if (vulns.length === 0) continue;

    const matchedVulns = vulns
      .filter(v => isVersionAffected(item.version, v.affected_versions))
      .map(v => ({
        title: v.title || 'Unknown vulnerability',
        cve_id: v.cve_id || null,
        cvss_score: v.cvss_score ?? null,
        cvss_rating: v.cvss_rating || classifyCVSS(v.cvss_score),
        patched_status: v.patched_status || null,
        remediation: v.remediation || null,
      }));

    if (matchedVulns.length > 0) {
      result.matches.push({
        software_slug: item.slug,
        software_type: item.type,
        detected_version: item.version,
        vulnerabilities: matchedVulns,
      });

      for (const vuln of matchedVulns) {
        result.totalVulnerabilities++;
        const rating = (vuln.cvss_rating || '').toLowerCase();
        if (rating === 'critical') result.criticalCount++;
        else if (rating === 'high') result.highCount++;
        else if (rating === 'medium') result.mediumCount++;
        else result.lowCount++;
      }
    }
  }

  return result;
}

function isVersionAffected(detectedVersion: string | null, affectedVersions: string | null): boolean {
  if (!detectedVersion) return true;
  if (!affectedVersions) return true;

  const affected = affectedVersions.trim();

  const lteMatch = affected.match(/^<=\s*([\d.]+)/);
  if (lteMatch) {
    return compareVersions(detectedVersion, lteMatch[1]) <= 0;
  }

  const ltMatch = affected.match(/^<\s*([\d.]+)/);
  if (ltMatch) {
    return compareVersions(detectedVersion, ltMatch[1]) < 0;
  }

  const rangeMatch = affected.match(/([\d.]+)\s*-\s*([\d.]+)/);
  if (rangeMatch) {
    return compareVersions(detectedVersion, rangeMatch[1]) >= 0 &&
           compareVersions(detectedVersion, rangeMatch[2]) <= 0;
  }

  const exactMatch = affected.match(/^([\d.]+)$/);
  if (exactMatch) {
    return compareVersions(detectedVersion, exactMatch[1]) === 0;
  }

  return true;
}

function compareVersions(a: string, b: string): number {
  const partsA = a.split('.').map(Number);
  const partsB = b.split('.').map(Number);
  const len = Math.max(partsA.length, partsB.length);

  for (let i = 0; i < len; i++) {
    const numA = partsA[i] || 0;
    const numB = partsB[i] || 0;
    if (numA < numB) return -1;
    if (numA > numB) return 1;
  }
  return 0;
}

function classifyCVSS(score: number | null): string | null {
  if (score === null || score === undefined) return null;
  if (score >= 9.0) return 'critical';
  if (score >= 7.0) return 'high';
  if (score >= 4.0) return 'medium';
  return 'low';
}

async function fetchFallbackVulnerabilities(
  slug: string,
  type: 'plugin' | 'theme' | 'core'
): Promise<Array<{ title: string | null; cve_id: string | null; cvss_score: number | null; cvss_rating: string | null; software_slug: string | null; affected_versions: string | null; patched_status: string | null; remediation: string | null; }>> {
  const results: Array<any> = [];

  // Try WPVulnerability API first (simpler, no auth)
  try {
    const wpvulnType = type === 'core' ? 'wordpresses' : type === 'plugin' ? 'plugins' : 'themes';
    const wpvulnUrl = `https://www.wpvulnerability.net/${wpvulnType}/${slug}`;
    const response = await fetchUrl(wpvulnUrl, { timeout: 10000 });

    if (response.statusCode === 200) {
      const data = JSON.parse(response.body);
      const vulns = data?.data?.vulnerability || data?.vulnerabilities || [];

      for (const v of (Array.isArray(vulns) ? vulns : [])) {
        results.push({
          title: v.name || v.title || null,
          cve_id: v.cve?.id || null,
          cvss_score: v.cvss?.score || null,
          cvss_rating: v.cvss?.rating || classifyCVSS(v.cvss?.score || null),
          software_slug: slug,
          affected_versions: v.operator?.max_version ? `<= ${v.operator.max_version}` : null,
          patched_status: v.operator?.patched ? 'patched' : 'unpatched',
          remediation: v.operator?.remediation || null,
        });
      }
    }
  } catch {
    // WPVulnerability API failed, try Wordfence
  }

  if (results.length > 0) return results;

  // Try Wordfence Intelligence API
  try {
    const wfUrl = `https://www.wordfence.com/api/intelligence/v2/vulnerabilities/software/${slug}`;
    const response = await fetchUrl(wfUrl, { timeout: 10000 });

    if (response.statusCode === 200) {
      const data = JSON.parse(response.body);

      for (const [, vuln] of Object.entries(data as Record<string, any>)) {
        results.push({
          title: vuln.title || null,
          cve_id: vuln.cve || null,
          cvss_score: vuln.cvss?.score || null,
          cvss_rating: vuln.cvss?.rating || classifyCVSS(vuln.cvss?.score || null),
          software_slug: slug,
          affected_versions: vuln.affected_versions ? JSON.stringify(vuln.affected_versions) : null,
          patched_status: vuln.patched ? 'patched' : 'unpatched',
          remediation: vuln.remediation || null,
        });
      }
    }
  } catch {
    // Wordfence API also failed
  }

  return results;
}
